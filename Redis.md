# Redis

1.Redis用过哪些数据数据，以及Redis底层怎么实现?<br/>

2.Redis缓存穿透，缓存雪崩？<br/>

缓存穿透是指一个根本不存在的数据，缓存层和存储层都不能命中，失去了缓存层保护存储层的意义；<br/>
解决：缓存空对象；布隆过滤器拦截；<br/>
最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的map中，一个一定不存在的数据会被 这个map拦截掉，从而避免了对底层存储系统的查询压力。<br/>
另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br/>

缓存雪崩是指redis服务节点突然宕机，导致大量查询全部堆积到存储层，可能会引起数据库宕机。<br/>
解决办法：1.redis高可用集群；2.依赖隔离组件做限流、服务降级 3.提前演练。<br/>
缓存雪崩还有一种情况是同一时间大量缓存一起失效，导致存储层DB瞬时压力过大；解决：控制缓存失效时间分散开来；<br/>
缓存击穿和缓存穿透的区别是，缓存击穿是针对某一key缓存，穿透是对应很多key；<br/>

3.如何使用Redis来实现分布式锁?<br/>
setNx set if not exists 当设置的key是当前节点中没有的，则返回成功。<br/>
所有系统都向redis设置同一个key及其过期时间，创建成功的获取锁，过期时间可防止锁忘记了释放；<br/>

Redis的并发竞争问题如何解决<br/>
Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。<br/>
对此有2种解决方法：<br/>
1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。<br/>
2.服务器角度，利用setnx实现锁。<br/>

Redis持久化的几种方式，优缺点是什么，怎么实现的<br/>
RDB：镜像全量持久化；实现方式是在服务端配置，当N秒内有M条数据更新就fork拆分出子进程进行数据写入磁盘dump.rdb；<br/>
运用技术：fork和copy-on-write：linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。<br/>
优点：文件小，恢复数据快；缺点：镜像全量持久化操作时间长，持久化过程中服务宕机会引起数据丢失; 数据量大的话，可能会导致服务器停顿几百毫秒；<br/>

AOF：appendonlyfile增量持久化；实现方式是将所有写和删除命令记录到日志文件；<br/>
优点：数据安全性高一致性好；同步策略：每秒同步、每修改同步、不同步；最多丢失一秒的数据；<br/>
缺点：文件偏大；运行效率比RDB方式差一些；灾难恢复会慢一些；<br/>

Redis的缓存失效策略<br/>
惰性删除：当客户端来查询该key时，发现已过期将数据删除；<br/>
定期删除：在配置文件中设置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次）多久检查过期数据并处理；<br/>

Redis的数据淘汰策略<br/>
redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）<br/>
redis 提供 6种数据淘汰策略：<br/>
　　． volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br/>
　　． volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br/>
　　． volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br/>
　　． allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br/>
　　． allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br/>
　　． no-enviction（驱逐）：禁止驱逐数据<br/>
　　注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br/>

Redis集群，高可用，原理<br/>
Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br/>
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。<br/>

Redis可以使用主从同步，从从同步。<br/>
第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。<br/>

